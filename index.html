<!doctype html>
<html>
<head></head>
<body bgcolor="#0000FF" style="padding: 0; margin: 0">
<canvas id="tutorial"></canvas>
<script src="/socket.io/socket.io.js"></script>
<script>
document.body.style.overflow = 'hidden';
var canvas = document.getElementById('tutorial');
var viewport = new Viewport(window.innerWidth || document.body.clientWidth, window.innerHeight|| document.body.clientHeight);
canvas.setAttribute('width', viewport.width);
canvas.setAttribute('height', viewport.height);
var ctx = canvas.getContext('2d');

var blocks = [], beasts = [], nests = [], dynamites = [], sprites = [];
var player;
var playing = true;
var is_debug = true;
var snd_effect_time = Date.now();
var block_size = 40;
var peaceful_beasts = false; // makes beasts move randomly instead of toward you
var server_time = 0;

var offline = !window.io;

if (offline) {
  window.emit = function(name, data) {
    handleEvent({name: name, data: data});
  };
  setTimeout(function() {
    init({seed: seed});
  }, 0);
  window.interval = setInterval;
  window.clearInt = clearInterval;
}
else {
  var socket = io(location.origin, {multiplex: false});
  socket.on('evt', handleEvent);
  socket.on('spawnWorld', init);
  socket.on('playEvents', function(events) {
    events.forEach(function(evt) {
      handleEvent(evt);
    });
  });

  window.emit = function(name, data) {
    socket.emit('evt', {name: name, data: data});
  };
  window.interval = function(cb, ms) {
    var secs = ms / 1000;
    data = {start: server_time, secs: secs, id: Math.random(), cb: cb};
    interval.fns.push(data);
    return data.id;
  };
  window.clearInt = function(id) {
    for (var n = 0; n < interval.fns.length; n++) {
      if (interval.fns[n].id == id)
        interval.fns.splice(n, 1);
    }
  };
  interval.fns = [];
}

function handleEvent(evt) {
  if (evt.name == 'move') {
    if (player.canMove(evt.data))
      player.move(evt.data);
  }
  else if (evt.name == 'pause') {
    playing = !playing;
  }
  else if (evt.name == 'time') {
    server_time = evt.time;
    interval.fns.forEach(function(data) {
      var diff = server_time - data.start;
      if (diff % data.secs == 0)
        data.cb();
    });
  }
}

function init(opts) {
  window.m = new MersenneTwister(opts.seed);
  window.regions = [
    {x: -1, y: -1, color: random(bg_colors)},
    {x: 0, y: -1, color: random(bg_colors)},
    {x: 1, y: -1, color: random(bg_colors)},
    {x: -1, y: 0, color: random(bg_colors)},
    {x: 0, y: 0, color: random(bg_colors)},
    {x: 1, y: 0, color: random(bg_colors)},
    {x: -1, y: 1, color: random(bg_colors)},
    {x: 0, y: 1, color: random(bg_colors)},
    {x: 1, y: 1, color: random(bg_colors)}
  ];
  spawnWorld(4, 1, 4);

  requestAnimationFrame(draw);
  interval(function() {
    if (!playing || !beasts.length) return;

    gainNode.gain.value = 0.05;
    snd_effect_time = Date.now();

    beasts.forEach(function(beast) {
      beast.move();
    });
  }, 1000);
}

var LEFT = 37;
var RIGHT = 39;
var UP = 40;
var DOWN = 38;
var SPACE = 32;

var vectors = {};
vectors[LEFT] = {x: -1, y: 0};
vectors[RIGHT] = {x: 1, y: 0};
vectors[UP] = {x: 0, y: 1};
vectors[DOWN] = {x: 0, y: -1};

var keys = {};
var bg_colors = ['#85C15B', '#CCCCCC', '#FFCC66', '#006600'];
var region_size = 40;

document.addEventListener('keydown', function(evt) {
  if (!playing || !vectors[evt.keyCode])
    return;

  var vect = vectors[evt.keyCode];
  console.log('about to emit move: ' + Date.now());
  emit('move', vect);
  // if (player.canMove(vect))
  //   player.move(vect);
  keys[evt.keyCode] = 1;
  setTimeout(function() {
    if (keys[evt.keyCode])
      keys[evt.keyCode] = 2;
  }, 500);
});

document.addEventListener('keyup', function(evt) {
  if (evt.keyCode == SPACE)
    emit('pause');
  //     playing = !playing;

  keys[evt.keyCode] = 0;
});

setInterval(function() {
  if (!playing) return;

  for (vect in vectors) {
    if (keys[vect] == 2) {
      var vector = vectors[vect];
      console.log('emitting move in setInterval: ' + Date.now());
      emit('move', vector);
      // if (player.canMove(vector))
      //   player.move(vector);
    }
  }
}, 100);

function spawnWorld(num_beasts, num_nests, num_dynamites) {
  player = new Player({x: 18, y: 18});
  sprites.push(player);

  var max_x = region_size;
  var max_y = region_size;
  for (var n = 0; n < num_beasts; n++)
    sprites.push(new Beast(getSpawnPosition(0, 0)));

  for (var x = -1; x <= 1; x++) {
    for (var y = -1; y <= 1; y++) {
      for (var n = 0; n < num_nests; n++)
        sprites.push(new Nest(getSpawnPosition(x, y)));
      for (var n = 0; n < num_dynamites; n++)
        sprites.push(new Dynamite(getSpawnPosition(x, y)));
    }
  }
  
  function getSpawnPosition(region_x, region_y) {
    var pos = {x: Math.floor(m.random() * max_x), y: Math.floor(m.random() * max_y)};
    pos.x += region_x * region_size;
    pos.y += region_y * region_size;
    if (collide(pos, sprites))
      pos = getSpawnPosition();
    return pos;
  }

  sprites.forEach(function(sprite) {
    sprite.arr.push(sprite);
  });

  for (var x = 0; x < region_size; ++x) {
    for (var y = 0; y < region_size; ++y) {
      if (m.random() > 0.85 && !collide({x: x, y: y}, sprites))
        blocks.push(new Block({x: x, y: y}));
    }
  }
  sprites = sprites.concat(blocks);
}

function draw() {
    ctx.clearRect(0, 0, viewport.width, viewport.height);
    regions.forEach(function(bg) {
      ctx.fillStyle = bg.color;
      ctx.fillRect(bg.x * region_size * block_size - viewport.x * block_size, bg.y * region_size * block_size - viewport.y * block_size, region_size * block_size, region_size * block_size);
    });

    // only play sound effects for 50ms
    if (gainNode.gain.value && Date.now() - snd_effect_time > 50)
      gainNode.gain.value = 0;

    sprites.forEach(function(sprite) {
        sprite.draw();
    });
    requestAnimationFrame(draw);
}

function collide(sprite, sprites) {
    var n_sprites = sprites.length;
    for (var n = 0; n < n_sprites; n++)
        if (sprites[n] != sprite && sprite.x == sprites[n].x && sprite.y == sprites[n].y)
            return sprites[n];
}

function Viewport(width, height) {
  this.x = 0;
  this.y = 0;
  this.width = width;
  this.height = height;
}
Viewport.prototype.follow = function(pos) {
  var perct_x = (pos.x - this.x) * block_size / this.width;
  var perct_y = (pos.y - this.y) * block_size / this.height;
  if (perct_x > .8) {
    var dest_x = Math.round(this.width * .75 / block_size);
    this.x = pos.x - dest_x;
  }
  else if (perct_x < .2) {
    var dest_x = Math.round(this.width * .25 / block_size);
    this.x = pos.x - dest_x; 
  }
  if (perct_y > .8) {
    var dest_y = Math.round(this.height * .75 / block_size);
    this.y = pos.y - dest_y;
  }
  else if (perct_y < .2) {
    var dest_y = Math.round(this.height * .25 / block_size);
    this.y = pos.y - dest_y;
  }
};

function Sprite(pos) {
  this.x = pos.x;
  this.y = pos.y;
  this.is_destroyed = false;
}
Sprite.prototype.canMove = function(vect) {
  if (!this.movable)
    return false;

  var sprite = collide(add(this, vect), sprites);
  if (sprite)
    return sprite.canMove(vect);
  else
    return true;
};
Sprite.prototype.move = function(vect) {  
  this.x += vect.x;
  this.y += vect.y;
  var sprite = collide(this, sprites);
  if (sprite && sprite.movable)
    sprite.move(vect);
};
Sprite.prototype.draw = function() {
  ctx.fillStyle = this.fillStyle;
  ctx.fillRect(this.x * block_size - viewport.x * block_size, this.y * block_size - viewport.y * block_size, block_size, block_size);
};
Sprite.prototype.destroy = function() {
  if (this.is_destroyed) return;
  this.is_destroyed = true;
  var ix = this.arr.indexOf(this);
  if (ix > -1)
    this.arr.splice(ix, 1);
  else
    warning('this not found in this.arr');
  
  ix = sprites.indexOf(this);
  if (ix > -1)
    sprites.splice(ix, 1);
  else
    warning('this not found in sprites');
};

function Player(pos) {
  Player.super_.call(this, pos);
  this.fillStyle = "#3333CC";
  this.arr = [this];
  this.movable = true;
}
inherits(Player, Sprite);
Player.prototype.move = function(vect) {
  Player.super_.prototype.move.apply(this, arguments);
  viewport.follow(this);
};
Player.prototype.destroy = function() {
  Player.super_.prototype.destroy.apply(this, arguments);
  playing = false;
};

function Beast(pos) {
  Beast.super_.call(this, pos);
  this.fillStyle = "rgb(0,0,0)";
  this.arr = beasts;
}
inherits(Beast, Sprite);

// a beast can only move in a certain direction
// (or, more accurately, something else can only *push* the beast in this direction)
// if the beast is against a block & will be squished
Beast.prototype.canMove = function(vect) {
  return collide(add(this, vect), blocks);
};

// move toward the player if possible but semi-randomly
Beast.prototype.move = function(vect) {
  // TODO: need to handle the case if a beast is pushed into another beast
  // they both get squished if there's a block at the end?
  // and they both get pushed if there's not?
  if (vect) {
    this.x += vect.x;
    this.y += vect.y;
    return;
  }

  var diff = difference(this, player);

  // Game Over:
  // I'm not sure how, but sometimes a beast can be right on top of a player
  // yet move() is still called...
  if (!diff.x && !diff.y)
    return player.destroy();

  // figure out optimal direction for beast to move
  if (peaceful_beasts) {
    var dir = {
      x: random([-1, 0, 1]),
      y: random([-1, 0, 1])
    };
  }
  else {
    var dir = {x: 0, y: 0};
    if (diff.x)
      dir.x = diff.x < 0 ? 1 : -1;
    if (diff.y)
      dir.y = diff.y < 0 ? 1 : -1;
  }
  
  // blocks-n-beasts (avoid colliding w/ blocks or beasts... or anything but the player)
  var bnb = sprites.slice();
  var player_ix = bnb.indexOf(player);
  bnb.splice(player_ix, 1);
  
  var directions = [];
  if (!collide(add(this, dir), bnb))
    directions.push(dir);

  var clock = clone(dir);
  var counter = clone(dir);
  // work your way both ways around the clock
  for (var n = 0; n < 3; ++n) {
    clock = clockwise(clock);
    counter = counterclock(counter);
    if (!collide(add(this, clock), bnb))
      directions.push(clock);
    if (!collide(add(this, counter), bnb))
      directions.push(counter);
  }

  // add the exact opposite direction
  clock = clockwise(clock);
  if (!collide(add(this, clock), bnb))
    directions.push(clock);

  var dir;
  for (var n = 0; n < directions.length; n++) {
    if (n == directions.length - 1) {
      dir = directions[n];
    }
    else if (m.random() < 0.7) {
      dir = directions[n];
      break;
    }
  }

    if (dir) {
      this.x += dir.x;
      this.y += dir.y;
    }

  // game over!
  if (this.x == player.x && this.y == player.y)
    player.destroy();
}

function add(sprite1, sprite2) {
    return {x: sprite1.x + sprite2.x, y: sprite1.y + sprite2.y};
}
function clone(dir) {
    return {x: dir.x, y: dir.y};
}

function Block(pos) {
  Block.super_.call(this, pos);
  this.fillStyle = "#888888";
  this.movable = true;
  this.arr = blocks;
  this.is_turret = false;
}
inherits(Block, Sprite);
Block.prototype.makeTurret = function() {
  if (this.is_turret) return;
  this.is_turret = true;
  this.fillStyle = "#666666";
  
  // a cleaner way to do this would be to have a single object
  // that represents the group of bricks and a way to get the blocks that are adjacent to that
  // instead, we share a last_destroy variable w/ the others to ensure no two adjacent turret blocks
  // destroy something within the space of 5 seconds
  var destroy_interval = 5 * 1000;
  interval(function() {
    if (Date.now() - this.last_destroy < destroy_interval)
      return;

    var adj = adjacent(this, beasts);
    if (adj.length) {
      random(adj).destroy();
      this.last_destroy = Date.now();
      adjacent(this, blocks).forEach(function(block) {
        block.last_destroy = Date.now();
      });
    }
  }.bind(this), destroy_interval);
};

Block.prototype.move = function(vect) {
    Block.super_.prototype.move.call(this, vect);
    
    // detect turret
    var adj_blocks = adjacent(this, blocks);
    if (adj_blocks.length == 3) {
      // if all 3 adjacent blocks are in the same corner
      var diff_blocks = adj_blocks.map(function(block) { return difference(this, block); }.bind(this));
      if (Math.abs(diff_blocks[0].x + diff_blocks[1].x + diff_blocks[2].x) == 2 &&
        Math.abs(diff_blocks[0].y + diff_blocks[1].y + diff_blocks[2].y) == 2) {

        // if none of them are touching any other blocks
        if (adjacent(adj_blocks[0], blocks).length == 3 &&
          adjacent(adj_blocks[1], blocks).length == 3 &&
          adjacent(adj_blocks[2], blocks).length == 3) {
            this.makeTurret();
            adj_blocks.forEach(function(block) {
              block.makeTurret();
            });
        }
      }
    }

    // detect beast-squishing
    var collide_beast = collide(this, beasts);
    if (collide_beast) {
        if (collide(add(this, vect), blocks))
            collide_beast.destroy();
        else
            collide_beast.move(vect);
    }
}

function Nest(pos) {
  Nest.super_.call(this, pos);
  this.fillStyle = "#FFFFFF";
  this.interval_id = interval(this.spawnBeast.bind(this), random([30, 45, 60, 75, 90]) * 1000);
  this.arr = nests;
}
inherits(Nest, Sprite);

Nest.prototype.spawnBeast = function() {
  if (!playing) return;

  var avail_coords = coords.filter(function(vect) {
    return !collide(add(this, vect), beasts);
  });
  if (!avail_coords)
    return;
  
  var vect = add(this, random(avail_coords));
  var beast = new Beast(vect);
  beasts.push(beast);
  sprites.push(beast);
};
Nest.prototype.destroy = function() {
  if (this.is_destroyed) return;
  clearInt(this.interval_id);
  Sprite.prototype.destroy.apply(this, arguments);
};

function Dynamite(pos) {
  Dynamite.super_.call(this, pos);
  this.fillStyle = "#BB0000";
  this.ticking = false;
  this.movable = true;
  this.arr = dynamites;
}
inherits(Dynamite, Sprite);
Dynamite.prototype.move = function() {
  // TODO: detect contact w/ another dynamite & set ticking to true
  Sprite.prototype.move.apply(this, arguments);
  var adj_dynamites = adjacent(this, dynamites);
  if (!adj_dynamites.length)
    return;
  adj_dynamites.forEach(function(dyn) {
    dyn.startTicking();
  });
  this.startTicking();
};
Dynamite.prototype.startTicking = function() {
  if (this.ticking) return;
  this.ticking = true;
  this.tick_times = 0;
  var interval_id = interval(function() {
    this.tick_times++
    if (this.tick_times < 4) {
      this.fillStyle = "rgb(125,0,0)";
      setTimeout(function() {
        this.fillStyle = "rgb(255,0,0)";
      }.bind(this), 100);
    }
    // SHE'S GONNA BLOW!!!
    else {
      clearInt(interval_id);
      var explosion_size = random([1, 2, 3]);
      adjacent(this, sprites, explosion_size).forEach(function(sprite) {
        if (sprite.destroy) {
          log('dynamite is destroying sprite');
          sprite.destroy();
        }
      });
      this.destroy();
    }
  }.bind(this), 1000);
};

var coords = [
  {x: 0, y: -1},
  {x: 1, y: -1},
  {x: 1, y: 0},
  {x: 1, y: 1},
  {x: 0, y: 1},
  {x: -1, y: 1},
  {x: -1, y: 0},
  {x: -1, y: -1}
];

function clockwise(vect) {
  var ix = whereIndex(coords, {x: vect.x, y: vect.y});
  ix++;

  // cycle around the circle
  if (ix >= coords.length)
    ix = 0;
  
  return clone(coords[ix]);
}

function counterclock(vect) {
  var ix = whereIndex(coords, {x: vect.x, y: vect.y});
  ix--;

  // cycle around the circle
  if (ix < 0)
    ix = coords.length - 1;

  return clone(coords[ix]);
}

function whereIndex(arr, vect) {
  var len = arr.length;
  for (var n = 0; n < len; n++)
    if (arr[n].x == vect.x && arr[n].y == vect.y)
      return n;
  throw new Error('Unable to find: ' + vect. x + ', ' + vect.y);
}

// copied from Node.js
function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
}

// pick random item from array
function random(arr) {
  return arr[Math.floor(m.random() * arr.length)];
}

// returns items from arr that are adjacent to coords
function adjacent(coords, arr, dist) {
  if (!dist)
    dist = 1;
  
  var adj = [];
  var len = arr.length;
  for (var n = 0; n < len; n++) {
    var sprite = arr[n];
    var diff = difference(sprite, coords);
    if (diff.x >= -dist && diff.x <= dist && diff.y >= -dist && diff.y <= dist)
      if (diff.x != 0 || diff.y != 0)
        adj.push(sprite);
  }
  return adj;
}

function difference(sprite1, sprite2) {
  return {x: sprite1.x - sprite2.x, y: sprite1.y - sprite2.y};
}

function log(msg) {
  if (is_debug)
    console.log(msg);
}

// setup sound effects
var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
var oscillator = audioCtx.createOscillator();
oscillator.type = 'square';
oscillator.frequency.value = 130.81;// C3 in hertz (http://www.phy.mtu.edu/~suits/notefreqs.html, https://github.com/kittykatattack/soundForGames)
oscillator.start();
var gainNode = audioCtx.createGain();
gainNode.gain.value = 0;
oscillator.connect(gainNode);
gainNode.connect(audioCtx.destination);

// from: https://gist.github.com/banksean/300494
var MersenneTwister = function(seed) {
  if (seed == undefined) {
    seed = new Date().getTime();
  } 
  /* Period parameters */  
  this.N = 624;
  this.M = 397;
  this.MATRIX_A = 0x9908b0df;   /* constant vector a */
  this.UPPER_MASK = 0x80000000; /* most significant w-r bits */
  this.LOWER_MASK = 0x7fffffff; /* least significant r bits */
 
  this.mt = new Array(this.N); /* the array for the state vector */
  this.mti=this.N+1; /* mti==N+1 means mt[N] is not initialized */
 
  this.init_genrand(seed);
}  
 
/* initializes mt[N] with a seed */
MersenneTwister.prototype.init_genrand = function(s) {
  this.mt[0] = s >>> 0;
  for (this.mti=1; this.mti<this.N; this.mti++) {
      var s = this.mt[this.mti-1] ^ (this.mt[this.mti-1] >>> 30);
   this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253)
  + this.mti;
      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
      /* In the previous versions, MSBs of the seed affect   */
      /* only MSBs of the array mt[].                        */
      /* 2002/01/09 modified by Makoto Matsumoto             */
      this.mt[this.mti] >>>= 0;
      /* for >32 bit machines */
  }
}
 
/* initialize by an array with array-length */
/* init_key is the array for initializing keys */
/* key_length is its length */
/* slight change for C++, 2004/2/26 */
MersenneTwister.prototype.init_by_array = function(init_key, key_length) {
  var i, j, k;
  this.init_genrand(19650218);
  i=1; j=0;
  k = (this.N>key_length ? this.N : key_length);
  for (; k; k--) {
    var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30)
    this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))
      + init_key[j] + j; /* non linear */
    this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
    i++; j++;
    if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
    if (j>=key_length) j=0;
  }
  for (k=this.N-1; k; k--) {
    var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);
    this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))
      - i; /* non linear */
    this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
    i++;
    if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
  }
 
  this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */ 
}
 
/* generates a random number on [0,0xffffffff]-interval */
MersenneTwister.prototype.genrand_int32 = function() {
  var y;
  var mag01 = new Array(0x0, this.MATRIX_A);
  /* mag01[x] = x * MATRIX_A  for x=0,1 */
 
  if (this.mti >= this.N) { /* generate N words at one time */
    var kk;
 
    if (this.mti == this.N+1)   /* if init_genrand() has not been called, */
      this.init_genrand(5489); /* a default initial seed is used */
 
    for (kk=0;kk<this.N-this.M;kk++) {
      y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
      this.mt[kk] = this.mt[kk+this.M] ^ (y >>> 1) ^ mag01[y & 0x1];
    }
    for (;kk<this.N-1;kk++) {
      y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
      this.mt[kk] = this.mt[kk+(this.M-this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];
    }
    y = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);
    this.mt[this.N-1] = this.mt[this.M-1] ^ (y >>> 1) ^ mag01[y & 0x1];
 
    this.mti = 0;
  }
 
  y = this.mt[this.mti++];
 
  /* Tempering */
  y ^= (y >>> 11);
  y ^= (y << 7) & 0x9d2c5680;
  y ^= (y << 15) & 0xefc60000;
  y ^= (y >>> 18);
 
  return y >>> 0;
}
 
/* generates a random number on [0,1)-real-interval */
MersenneTwister.prototype.random = function() {
  return this.genrand_int32()*(1.0/4294967296.0); 
  /* divided by 2^32 */
}

</script>
</body>
</html>
