<canvas id="tutorial" width="1800" height="1800"></canvas>
<script>
document.body.style.overflow = 'hidden';
var canvas = document.getElementById('tutorial');
var ctx = canvas.getContext('2d');

var blocks = [], beasts = [], nests = [], player, sprites;
var playing = true;
var snd_effect_time = Date.now();

function init() {
  player = new Player(18, 18);
  spawnBeastsBlocks();
  sprites = blocks.concat(beasts, nests);
  sprites.push(player);

  requestAnimationFrame(draw);
  setInterval(function() {
    if (!playing || !beasts.length) return;

    gainNode.gain.value = 0.05;
    snd_effect_time = Date.now();

    beasts.forEach(function(beast) {
      beast.move();
    });
  }, 500);
}

var LEFT = 37;
var RIGHT = 39;
var UP = 40;
var DOWN = 38;
var SPACE = 32;

var vectors = {};
vectors[LEFT] = {x: -1, y: 0};
vectors[RIGHT] = {x: 1, y: 0};
vectors[UP] = {x: 0, y: 1};
vectors[DOWN] = {x: 0, y: -1};

var keys = {};

document.addEventListener('keydown', function(evt) {
  if (!playing || !vectors[evt.keyCode])
    return;

  player.move(vectors[evt.keyCode]);
  keys[evt.keyCode] = 1;
  setTimeout(function() {
    if (keys[evt.keyCode])
      keys[evt.keyCode] = 2;
  }, 500);
});

document.addEventListener('keyup', function(evt) {
    if (evt.keyCode == SPACE)
        playing = !playing;

    keys[evt.keyCode] = 0;
});

setInterval(function() {
  if (!playing) return;

  for (vect in vectors)
    if (keys[vect] == 2)
      player.move(vectors[vect]);
}, 100);

function spawnBeastsBlocks() {
    for (var x = 0; x < 36; ++x) {
        for (var y = 0; y < 36; ++y) {
            if (x != player.x && y != player.y) {
              if (Math.random() > 0.998)
                nests.push(new Nest(x, y));
              else if (Math.random() > 0.993)
                beasts.push(new Beast(x, y));
              else if (Math.random() > 0.70)
                blocks.push(new Block(x, y));
          }
        }
    }
}

function draw() {
    ctx.clearRect(0,0,1800,1800); // clear canvas

    // only play sound effects for 50ms
    if (gainNode.gain.value && Date.now() - snd_effect_time > 50)
      gainNode.gain.value = 0;

    sprites.forEach(function(sprite) {
        sprite.draw();
    });
    requestAnimationFrame(draw);
}

function collide(sprite, sprites) {
    var n_sprites = sprites.length;
    for (var n = 0; n < n_sprites; n++)
        if (sprites[n] != sprite && sprite.x == sprites[n].x && sprite.y == sprites[n].y)
            return sprites[n];
}

function Sprite() {
}
Sprite.prototype.move = function(vect) {  
  this.x += vect.x;
  this.y += vect.y;
  var collide_block = collide(this, blocks);
  if (collide_block)
      collide_block.move(vect);
};
Sprite.prototype.draw = function() {
  ctx.fillStyle = this.fillStyle;
  ctx.fillRect(this.x * 20, this.y * 20, 20, 20);
};
Sprite.prototype.destroy = function() {
  var ix = this.arr.indexOf(this);
  this.arr.splice(ix, 1);
  ix = sprites.indexOf(this);
  sprites.splice(ix, 1);
};

function Player(x, y) {
  this.x = x;
  this.y = y;
  this.fillStyle = "rgb(100,100,255)";
}
inherits(Player, Sprite);

function Beast(x, y) {
  this.x = x;
  this.y = y;
  this.fillStyle = "rgb(0,0,0)";
  this.arr = beasts;
}
inherits(Beast, Sprite);

// move toward the player if possible but semi-randomly
Beast.prototype.move = function(vect) {
  // TODO: need to handle the case if a beast is pushed into another beast
  // they both get squished if there's a block at the end?
  // and they both get pushed if there's not?
  if (vect) {
    this.x += vect.x;
    this.y += vect.y;
    return;
  }

  var diff_x = this.x - player.x;
  var diff_y = this.y - player.y;

  // Game Over:
  // I'm not sure how, but sometimes a beast can be right on top of a player
  // yet move() is still called...
  if (!diff_x && !diff_y)
    return playing = false;

  // figure out optimal direction for beast to move
  var dir = {x: 0, y: 0};
  if (diff_x)
    dir.x = diff_x < 0 ? 1 : -1;
  if (diff_y)
    dir.y = diff_y < 0 ? 1 : -1;

  // blocks-n-beasts (avoid colliding w/ blocks or other beasts)
  var bnb = blocks.concat(beasts);
  
  var directions = [];
  if (!collide(add(this, dir), bnb))
    directions.push(dir);

  var clock = clone(dir);
  var counter = clone(dir);
  // work your way both ways around the clock
  for (var n = 0; n < 3; ++n) {
    clock = clockwise(clock);
    counter = counterclock(counter);
    if (!collide(add(this, clock), bnb))
      directions.push(clock);
    if (!collide(add(this, counter), bnb))
      directions.push(counter);
  }

  // add the exact opposite direction
  clock = clockwise(clock);
  if (!collide(add(this, clock), bnb))
    directions.push(clock);

  var dir;
  for (var n = 0; n < directions.length; n++) {
    if (n == directions.length - 1) {
      dir = directions[n];
    }
    else if (Math.random() < 0.7) {
      dir = directions[n];
      break;
    }
  }

    if (dir) {
      this.x += dir.x;
      this.y += dir.y;
    }

  // game over!
  if (this.x == player.x && this.y == player.y)
    playing = false;
}

function add(sprite1, sprite2) {
    return {x: sprite1.x + sprite2.x, y: sprite1.y + sprite2.y};
}
function clone(dir) {
    return {x: dir.x, y: dir.y};
}

function Block(x, y) {
  this.x = x;
  this.y = y;
  this.fillStyle = "rgb(200,200,200)";
}
inherits(Block, Sprite);
Block.prototype.move = function(vect) {
    Block.super_.prototype.move.call(this, vect);
    var collide_beast = collide(this, beasts);
    if (collide_beast) {
        if (collide(add(this, vect), blocks))
            collide_beast.destroy();
        else
            collide_beast.move(vect);
    }
}

function Nest(x, y) {
  this.x = x;
  this.y = y;
  this.fillStyle = "rgb(115,115,115)";
  this.interval_id = setInterval(this.spawnBeast.bind(this), 10 * 1000);
}
inherits(Nest, Sprite);

Nest.prototype.spawnBeast = function() {
  if (!playing) return;

  var avail_coords = coords.filter(function(vect) {
    return !collide(add(this, vect), beasts);
  });
  if (!avail_coords)
    return;
  
  var vect = add(this, random(avail_coords));
  var beast = new Beast(vect.x, vect.y);
  beasts.push(beast);
  sprites.push(beast);
};
Nest.prototype.destroy = function() {
  clearInterval(this.interval_id);
  Sprite.prototype.destroy.apply(this, arguments);
};

var coords = [
  {x: 0, y: -1},
  {x: 1, y: -1},
  {x: 1, y: 0},
  {x: 1, y: 1},
  {x: 0, y: 1},
  {x: -1, y: 1},
  {x: -1, y: 0},
  {x: -1, y: -1}
];

function clockwise(vect) {
  var ix = whereIndex(coords, {x: vect.x, y: vect.y});
  ix++;

  // cycle around the circle
  if (ix >= coords.length)
    ix = 0;
  
  return clone(coords[ix]);
}

function counterclock(vect) {
  var ix = whereIndex(coords, {x: vect.x, y: vect.y});
  ix--;

  // cycle around the circle
  if (ix < 0)
    ix = coords.length - 1;

  return clone(coords[ix]);
}

function whereIndex(arr, vect) {
  var len = arr.length;
  for (var n = 0; n < len; n++)
    if (arr[n].x == vect.x && arr[n].y == vect.y)
      return n;
  throw new Error('Unable to find: ' + vect. x + ', ' + vect.y);
}

// copied from Node.js
function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
}

// pick random item from array
function random(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

// setup sound effects
var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
var oscillator = audioCtx.createOscillator();
oscillator.type = 'square';
oscillator.frequency.value = 130.81;// C3 in hertz (http://www.phy.mtu.edu/~suits/notefreqs.html, https://github.com/kittykatattack/soundForGames)
oscillator.start();
var gainNode = audioCtx.createGain();
gainNode.gain.value = 0;
oscillator.connect(gainNode);
gainNode.connect(audioCtx.destination);

init();
</script>